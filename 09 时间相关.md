#  Chapter9 时间相关
## 1.日期间隔
<img width="576" alt="截屏2022-07-08 下午9 11 36" src="https://user-images.githubusercontent.com/105503216/177998662-ddb1f4aa-be33-4a35-b7ee-873e2e08e57f.png">. 

``` sql
SELECT w1.id
FROM Weather w1
JOIN Weather w2
ON DATEDIFF(w1.recordDate, w2.recordDate) = 1.  # 关于日期的间隔 使用DATEDIFF 不要直接使用数字 + 几
WHERE w1.Temperature > w2.Temperature

# 也可以使用DATE_ADD
SELECT w1.id
FROM Weather w1
JOIN Weather w2
ON W1.recordDate = DATE_ADD(W2.recordDate, interval 1 day) 
WHERE w1.Temperature > w2.Temperature
```

## 2.留存率
<img width="636" alt="image" src="https://user-images.githubusercontent.com/105503216/178090821-2a6d2cef-6777-4b70-b28b-365d81add1ca.png">

``` sql
WITH sub1 AS (
SELECT COUNT(DISTINCT device_id, date) AS number1
FROM question_practice_detail
),                        		# 这里要用逗号隔开 且不能再加上WITH
sub2 AS (
SELECT COUNT(DISTINCT q1.device_id, q1.date) AS number2
FROM question_practice_detail q1
JOIN question_practice_detail q2
ON DATEDIFF(q2.date, q1.date) = 1 AND
    q1.device_id = q2.device_id
)
SELECT number2 / number1 AS avg_ret 	# 注意这里一定要是columns的名字 不能是sub的名字
FROM sub1, sub2;    			# 从两个sub中取columns
```

## 3.xx天内的活跃用户 & xx天内的留存用户
<img width="666" alt="image" src="https://user-images.githubusercontent.com/105503216/178098927-00fd1849-4bf5-4b18-835f-181bedcf4373.png">

``` sql
WITH sub1 AS(
SELECT date AS Date, 
	COUNT(DISTINCT user_id) AS 活跃用户数     # 每日的活跃用户数 是group_by日期之后 count(distinct user_id)
FROM active
GROUP BY date
) ,
sub2 AS (
SELECT a1.date AS Date, 
	COUNT(DISTINCT a1.user_id) AS 活跃30天留存用户数
FROM active a1
JOIN active a2
ON a1.user_id = a2.user_id AND
	DATEDIFF(a2.date, a1.date) < 30 AND     # 注意这里小于30
    DATEDIFF(a2.date, a1.date) > 0          # 这里一定要大于0 不然在改日期之前的也会被取到
GROUP BY a1.date
)
SELECT sub1.Date AS Date, 
sub1.活跃用户数,
CASE WHEN sub2.活跃30天留存用户数 IS NULL THEN 0
	ELSE 活跃30天留存用户数
END AS 活跃30天留存用户数
FROM sub1
LEFT JOIN sub2
ON sub1.Date = sub2.Date
```
事实上，可以通过user_id的join 看两个日期是不是相隔xx天来判断  

``` sql
SELECT 
	a1.date,
    COUNT(DISTINCT a1.user_id) AS '每日活跃用户数',
    SUM(DATEDIFF(a2.date, a1.date) < 30 AND DATEDIFF(a2.date, a1.date) > 0) AS '活跃30天留存用户数'		 # 依然要注意必须大于0
FROM active a1
LEFT JOIN active a2
ON a1.user_id = a2.user_id
GROUP BY a1.date
```

## 4.查询次日留存用户数、三日留存用户数、七日留存用户数、次日留存率、三日留存率、七日留存率

``` sql
-- 用户注册表
create table user_info
(
    user_id  varchar(10) primary key,
    reg_time datetime
);
 
insert into user_info
values ('u_01', '2020-01-01 09:15:00'),
       ('u_02', '2020-01-01 00:04:00'),
       ('u_03', '2020-01-01 22:16:00'),
       ('u_04', '2020-01-01 20:32:00'),
       ('u_05', '2020-01-01 13:59:00'),
       ('u_06', '2020-01-01 21:28:00'),
       ('u_07', '2020-01-01 14:03:00'),
       ('u_08', '2020-01-01 11:00:00'),
       ('u_09', '2020-01-01 23:57:00'),
       ('u_10', '2020-01-01 04:46:00'),
       ('u_11', '2020-01-02 14:21:00'),
       ('u_12', '2020-01-02 11:15:00'),
       ('u_13', '2020-01-02 07:26:00'),
       ('u_14', '2020-01-02 10:34:00'),
       ('u_15', '2020-01-02 08:22:00'),
       ('u_16', '2020-01-02 14:23:00'),
       ('u_17', '2020-01-03 09:20:00'),
       ('u_18', '2020-01-03 11:21:00'),
       ('u_19', '2020-01-03 12:17:00'),
       ('u_20', '2020-01-03 15:26:00');
 
-- 登陆日志表
create table login_log
(
    user_id    varchar(10),
    login_time datetime,
    primary key (user_id, login_time)
);
 
insert into login_log
values ('u_02', '2020-01-02 00:14:00'),
       ('u_10', '2020-01-02 08:32:00'),
       ('u_03', '2020-01-02 09:20:00'),
       ('u_08', '2020-01-02 10:07:00'),
       ('u_04', '2020-01-02 10:29:00'),
       ('u_09', '2020-01-02 11:45:00'),
       ('u_05', '2020-01-02 12:19:00'),
       ('u_01', '2020-01-02 14:29:00'),
       ('u_15', '2020-01-03 00:26:00'),
       ('u_14', '2020-01-03 11:18:00'),
       ('u_11', '2020-01-03 13:18:00'),
       ('u_16', '2020-01-03 14:33:00'),
       ('u_06', '2020-01-04 07:51:00'),
       ('u_18', '2020-01-04 08:11:00'),
       ('u_07', '2020-01-04 09:27:00'),
       ('u_10', '2020-01-04 10:59:00'),
       ('u_20', '2020-01-04 11:51:00'),
       ('u_03', '2020-01-04 12:37:00'),
       ('u_17', '2020-01-04 15:07:00'),
       ('u_08', '2020-01-04 16:35:00'),
       ('u_01', '2020-01-04 19:29:00'),
       ('u_14', '2020-01-05 08:03:00'),
       ('u_12', '2020-01-05 10:27:00'),
       ('u_15', '2020-01-05 16:33:00'),
       ('u_19', '2020-01-06 09:03:00'),
       ('u_20', '2020-01-06 15:26:00'),
       ('u_04', '2020-01-08 11:03:00'),
       ('u_05', '2020-01-08 12:54:00'),
       ('u_06', '2020-01-08 19:22:00'),
       ('u_13', '2020-01-09 10:20:00'),
       ('u_15', '2020-01-09 16:40:00'),
       ('u_18', '2020-01-10 21:34:00');
 
 
-- 查询次日留存用户数、三日留存用户数、七日留存用户数、次日留存率、三日留存率、七日留存率
SELECT 
    DATE(u.reg_time),
    COUNT(DISTINCT u.user_id) AS number_of_user,                           # 看每天有多少人
    SUM(IF(DATEDIFF(l.login_time, u.reg_time)=1,1,0)) AS '次日留存用户数',           # 如果是相距1 那么就返回true 求和 就可以得到有多少人在次日登陆
    SUM(IF(DATEDIFF(l.login_time, u.reg_time)=3,1,0)) AS '三日留存用户数',
    SUM(IF(DATEDIFF(l.login_time, u.reg_time)=7,1,0)) AS '七日留存用户数',
    CONCAT(ROUND(SUM(IF(DATEDIFF(l.login_time, u.reg_time)=1,1,0)) / COUNT(DISTINCT u.user_id) * 100, 2), '%') AS '次日留存率',
    CONCAT(ROUND(SUM(IF(DATEDIFF(l.login_time, u.reg_time)=3,1,0)) / COUNT(DISTINCT u.user_id) * 100, 2), '%') AS '三日留存率',
    CONCAT(ROUND(SUM(IF(DATEDIFF(l.login_time, u.reg_time)=7,1,0)) / COUNT(DISTINCT u.user_id) * 100, 2), '%') AS '七日留存率'
FROM user_info u
LEFT JOIN login_log l                                                      # 这里LEFT JOIN一下
ON u.user_id = l.user_id
GROUP BY DATE(u.reg_time)
```

## 5.关于错位的时间差  
<img width="981" alt="image" src="https://user-images.githubusercontent.com/105503216/178136211-bfbaf92a-98a1-4717-8aa3-ede4bad3e63f.png">  

``` sql
WITH sub1 AS
(SELECT 
	Driver_id, 
	TIMESTAMPDIFF(minute, 
				  LAG(end_time, 1) OVER (PARTITION BY Driver_id ORDER BY end_time), 
				  Start_time) AS duration             # 注意TIMESTAMPDIFF是后面 - 前面 和DATEDIFF不同！！！  
FROM Driver_game
WHERE Driver_id IN 
	(SELECT Driver_id
	FROM Driver_game
	GROUP BY Driver_id
	HAVING COUNT(*) > 1)
)
SELECT Driver_id, AVG(duration) AS avg_duration
FROM sub1
GROUP BY Driver_id;
```
或者也可以通过lag之后的NULL去掉  
``` sql
select Driver_id,avg(TimeStampDiff(minute,end_time,next_start_time)) as '游戏平均间隔（分钟）'
from(
    select *,lead(start_time) over(partition by driver_id order by start_time)as next_start_time
    from Driver_game
        )as t1
where next_start_time is not null     # 因为只玩了一次的人的lead也会是null 所以把null去掉
group by Driver_id;
```

## 6.关于和最大日期相差的问题
<img width="691" alt="image" src="https://user-images.githubusercontent.com/105503216/179268418-dc11c786-ef6f-4a4b-b33a-e5c4bc876a2a.png">  
<img width="690" alt="image" src="https://user-images.githubusercontent.com/105503216/179268866-8c3e5753-a734-4772-9798-cac87f811664.png">

``` sql
SELECT i.tag,
    SUM(IF(if_retweet=1,1,0)) AS retweet_cut,
    ROUND(SUM(IF(if_retweet=1,1,0)) / COUNT(*),3) AS retweet_rate
FROM tb_user_video_log l
JOIN tb_video_info i
ON l.video_id = i.video_id
WHERE TIMESTAMPDIFF(day,(SELECT MAX(end_time)) FROM tb_user_video_log),l.end_time) < 30
ORDER BY retweet_rate DESC;
```
这一题注意：  
1.因为是和最大日期比较 所以不需要大于0  
2.求最大日期的时候 一定要用sub 不可以直接max   
3.sub之后一定要用（）括起来

## 7.每月的涨粉率（没有涨粉的作者和没有涨粉的月份去掉）
<img width="635" alt="image" src="https://user-images.githubusercontent.com/105503216/179441156-233045ff-a7a8-4167-b31e-d405ffa3d85d.png">  
<img width="642" alt="image" src="https://user-images.githubusercontent.com/105503216/179441186-264e6588-9595-4b02-b1ec-851a57953d86.png">

``` sql
 SELECT author, month, 
    ROUND(change_number / play_number,3) AS fans_growth_rate, 
    SUM(change_number) OVER (PARTITION BY author ORDER BY month) AS total_fans   # sum累加的在外面再写一遍
 FROM   
    (SELECT author, 
        DATE_FORMAT(l.start_time,'%Y-%m') AS month,           # 使用TIME_FORMAT可以提取出想要的年/年月等等格式
        SUM(IF(if_follow=2,-1,if_follow)) AS change_number,   # 这里正好1就是需要求的1
        COUNT(*) AS play_number
    FROM tb_video_info i
    JOIN tb_user_video_log l
    ON i.video_id =l.video_id
    WHERE YEAR(start_time)=2021
    GROUP BY author, month) sub1
    ORDER BY author, total_fans;
```
