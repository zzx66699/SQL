# Chapter11 高频考点汇总

## 聚合函数
GROUP BY 和 HAVING
## 窗口函数
窗口函数也叫OLAP函数（Online Anallytical Processing，联机分析处理）  
<窗口函数>的位置，可以放以下两种函数：  
专用窗口函数，包括后面要讲到的rank, dense_rank, row_number等专用窗口函数。  
聚合函数，如sum. avg, count, max, min等  
<img width="729" alt="image" src="https://user-images.githubusercontent.com/105503216/180232958-21adade3-4d25-4e03-ad91-31583b73e208.png">
<img width="718" alt="image" src="https://user-images.githubusercontent.com/105503216/180233037-e3eb6342-5274-4a67-a64c-0b5a38fdaf7c.png">

## 列转换

EXERCISE1
<img width="886" alt="image" src="https://user-images.githubusercontent.com/105503216/180235702-6e94b4a0-9942-4ebb-a2f6-1ebfc98cb285.png">  
<img width="461" alt="image" src="https://user-images.githubusercontent.com/105503216/180237555-48256a73-ce75-45af-b267-7f8caf8e8f10.png">   

如果不分组 原数据有多少行 就有多少行  
按照人物分组 用sum/max选出那个唯一的非0分数  

EXERCISE2 
Students Report By Geography  
<img width="633" alt="image" src="https://user-images.githubusercontent.com/105503216/191899514-a28e470d-1cb7-4932-982c-e88f75556374.png">  

``` SQL
SELECT 
    MAX(CASE WHEN continent = 'America' THEN name END) AS America,
    MAX(CASE WHEN continent = 'Asia' THEN name END) AS Asia,
    MAX(CASE WHEN continent = 'Europe' THEN name END) AS Europe
FROM 
    (SELECT name, continent, ROW_NUMBER() OVER (PARTITION BY continent ORDER BY name) AS rk  # 如果没有这一步 直接case when 原数据有多少行就会有多少行
    FROM Student) sub1
GROUP BY rk
```

<img width="308" alt="image" src="https://user-images.githubusercontent.com/105503216/191900281-509b9ee4-b996-462f-abc1-a203e0a0277f.png">




## 求留存率
1. 求用户首次登陆后第二天依然登陆的比率  
思路：求出每个用户首次登陆的日期，和原来的表格（一定要是同一个用户一个日期在一行的表）合并；  
     判断是不是相差一天，是就是1，求和；  
     求所有unique的用户有几个，和上面的相除  
     
<img width="624" alt="image" src="https://user-images.githubusercontent.com/105503216/190852831-55e2e305-2040-4d08-a3b7-09e036850975.png">  
     
``` sql
SELECT 
    ROUND(SUM(CASE 
                WHEN DATEDIFF(a.event_date, sub1.first_log) = 1 THEN 1
                ELSE 0 END) / COUNT(DISTINCT a.player_id), 2) AS fraction
FROM 
    (SELECT player_id, MIN(event_date) AS first_log
    FROM Activity
    GROUP BY player_id) sub1
RIGHT JOIN Activity a
ON sub1.player_id = a.player_id
```

2. 求
